<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Emil Plesnik, Marand d.o.o." />

<meta name="date" content="2015-11-13" />

<title>Cycling analysis through GPS data</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amargin%2Dleft%3A210px%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Aposition%3A%20fixed%3B%0Aleft%3A%200%3B%0Atop%3A%2050px%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20200px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0Aoverflow%3Aauto%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">Cycling analysis through GPS data</h1>
<h4 class="author"><em>Emil Plesnik, Marand d.o.o.</em></h4>
<h4 class="date"><em>2015-11-13</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#segmenting-time">Segmenting time</a></li>
<li><a href="#detection-and-categorization-of-climbs">Detection and categorization of climbs</a></li>
<li><a href="#power-calculation">Power calculation</a></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This demonstration presents the <code>cycleR</code> package, which enables calculation of advanced advanced cycling parameters based on GPS data of the cycling route, for example power output, climb categorization, route-time segmentation. Calculations used in the package are based on <a href="https://strava.zendesk.com/forums/20246821-Strava-Glossary-Calculations">Strava glossary &amp; calculations</a> and are described in detail below.</p>
</div>
<div id="segmenting-time" class="section level2">
<h2>Segmenting time</h2>
<p>The <code>segment_time</code> function determines the total time, moving time and resting time on a cycling route described with GPS data. Additionally, the function calculates the time spent ascending, descending and on the flat. Absolute and relative values of these parameters are combined in a data frame which is returned in a list along with the indexes of moving and resting samples of input GPS data. The input arguments of the function is the <code>gps</code> data frame containing GPS data. The GPS data frame has to be prepared before, for example using the package <a href="https://github.com/ehrscape/R-project/tree/master/ParseGPX"><code>parseGPX</code></a>. The function is called with:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">time_segmentation &lt;-<span class="st"> </span><span class="kw">segment_time</span>(gps, resting_ind)</code></pre></div>
<p>To inspect in detail what the function does, we have to first load the sample data frame <code>gps</code> with GPS data of a cycling route located within the <code>cycleR</code> package</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">load</span>(<span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;gps.Rda&quot;</span>, <span class="dt">package=</span><span class="st">&quot;cycleR&quot;</span>))
<span class="kw">str</span>(gps, <span class="dt">strict.width =</span> <span class="st">&quot;wrap&quot;</span>)</code></pre></div>
<pre><code>## 'data.frame':    7771 obs. of  5 variables:
## $ lon : num 14.4 14.4 14.4 14.4 14.4 ...
## $ lat : num 46 46 46 46 46 ...
## $ ele : num 296 296 296 296 296 ...
## $ time : chr &quot;2015-06-02T14:59:55Z&quot; &quot;2015-06-02T15:01:55Z&quot;
##    &quot;2015-06-02T15:01:56Z&quot; &quot;2015-06-02T15:01:57Z&quot; ...
## $ tz_CEST: chr &quot;2015-06-02 16:59:55&quot; &quot;2015-06-02 17:01:55&quot; &quot;2015-06-02
##    17:01:56&quot; &quot;2015-06-02 17:01:57&quot; ...</code></pre>
<p>The function begins with converting the time vector of the GPS data to <code>POSIXct</code> format</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gps$time &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(gps$time, <span class="dt">format =</span> <span class="st">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>)</code></pre></div>
<p>This is followed by calculating and prepairing six additional variables required for calculating the final result. The first one is <code>delta_time</code> which contains the time differences between the GPS samples. The time differences are calculated simply with the <code>diff</code> function and they have to be converted from POSIXct to numeric format</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;delta_time&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$delta_time &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, <span class="kw">as.numeric</span>(<span class="kw">diff</span>(gps$time)))
  }</code></pre></div>
<p>The second variable is <code>d</code> containing the distances between GPS sample points. The distances in <code>d</code> are calculated by applying the <code>distanceGPS</code> function of the <a href="https://github.com/ehrscape/R-project/tree/master/AnalyzeGPS"><code>analyzeGPS</code> package</a> on the latitude and longitude data of <code>gps</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;d&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$d &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">distanceGPS</span>(<span class="dt">lat1 =</span> gps$lat[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lat) -<span class="st"> </span>
<span class="st">        </span><span class="dv">1</span>)], <span class="dt">lon1 =</span> gps$lon[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lon) -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">lat2 =</span> gps$lat[<span class="dv">2</span>:<span class="kw">length</span>(gps$lat)], 
        <span class="dt">lon2 =</span> gps$lon[<span class="dv">2</span>:<span class="kw">length</span>(gps$lon)]))
}</code></pre></div>
<p>The third variable is <code>speed</code> containing the average velocities between GPS sample points. The velocity values are calculated by applying the <code>speedGPS</code> function of the <code>analyzeGPS</code> package on the <code>time</code> and previously calculated variable <code>d</code> of the <code>gps</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;speed&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$speed &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">speedGPS</span>(gps$time, gps$d[-<span class="dv">1</span>]))
}</code></pre></div>
<p>The fourth, fifth and sixth variables are <code>ele_smooth</code>, <code>d_smooth</code> and <code>grade_smooth</code> containing smoothed elevation, distances and hill grade values, respectively. Elevation and distances values are smoothed using rolling mean (function <code>rollapply</code> of the <code>zoo</code> package) with the smoothing window <code>win_smooth</code> approximately 60 seconds long. The <code>grade_smooth</code> variable is then calculated from the <code>ele</code> and <code>d_smooth</code> variables using the <code>gradeGPS</code> function of the <code>analyzeGPS</code> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;grade_smooth&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    <span class="co"># Smooth out the elevation and hill grade vectors usng rolling mean value</span>
    <span class="co"># Length of the smoothing window is determined so that it's approximately 1</span>
    <span class="co"># minute long</span>
    win_smooth &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">60</span>/<span class="kw">as.numeric</span>(<span class="kw">difftime</span>(<span class="kw">tail</span>(gps$time, <span class="dv">1</span>), gps$time[<span class="dv">1</span>], 
        <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)/<span class="kw">length</span>(gps$time)), <span class="dt">digits =</span> -<span class="dv">1</span>)
    ele &lt;-<span class="st"> </span>zoo::<span class="kw">rollmean</span>(gps$ele, win_smooth)
    d_smooth &lt;-<span class="st"> </span>zoo::<span class="kw">rollapply</span>(gps$d, win_smooth, mean)
    grade &lt;-<span class="st"> </span>analyzeGPS::<span class="kw">gradeGPS</span>(ele, d_smooth)
    
    <span class="co"># Insert the smoothened vectors into the main data frame</span>
    gps$ele_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
    gps$ele_smooth[<span class="dv">1</span>:<span class="kw">length</span>(ele)] &lt;-<span class="st"> </span>ele
    gps$d_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
    gps$d_smooth[<span class="dv">1</span>:<span class="kw">length</span>(d_smooth)] &lt;-<span class="st"> </span>d_smooth
    gps$grade_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
    gps$grade_smooth[<span class="dv">2</span>:(<span class="kw">length</span>(grade) +<span class="st"> </span><span class="dv">1</span>)] &lt;-<span class="st"> </span>grade
}</code></pre></div>
<p>For consistency we add a <code>NA</code> value to each calculated additional variable and integrate it to the <code>gps</code> data frame. With the <code>if</code> sentence before each calculation, the input <code>gps</code> data frame is first checked if it already contains the variable to be calculated. If it is already there, it is not calculated again. After the initial preparation, the <code>gps</code> data frame looks something like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(gps, <span class="dt">strict.width =</span> <span class="st">&quot;wrap&quot;</span>)</code></pre></div>
<pre><code>## 'data.frame':    7771 obs. of  11 variables:
## $ lon : num 14.4 14.4 14.4 14.4 14.4 ...
## $ lat : num 46 46 46 46 46 ...
## $ ele : num 296 296 296 296 296 ...
## $ time : POSIXct, format: &quot;2015-06-02 14:59:55&quot; &quot;2015-06-02 15:01:55&quot; ...
## $ tz_CEST : chr &quot;2015-06-02 16:59:55&quot; &quot;2015-06-02 17:01:55&quot; &quot;2015-06-02
##    17:01:56&quot; &quot;2015-06-02 17:01:57&quot; ...
## $ delta_time : num NA 120 1 1 1 1 1 1 1 1 ...
## $ d : num NA 6.48 2.98 3.56 4.11 ...
## $ speed : num NA 0.054 2.983 3.558 4.114 ...
## $ ele_smooth : num 301 301 301 301 301 ...
## $ d_smooth : num NA 7.25 7.27 7.38 7.46 ...
## $ grade_smooth: num NA 0.01352 0.0121 0.01084 0.00939 ...</code></pre>
<p>Then <code>total_time</code> is calculated by summing up all values from the <code>delta_time</code> variable. All GPS samples with average speed less than 1 m/s (3.6 km/h) are determined as resting (standing still) and all those with average speed more than or equal 1 m/s are determined as moving/cycling. In both cases the sample indexes (<code>resting_ind</code>, <code>moving_ind</code>) and sum of corresponding <code>delta_time</code> values (<code>resting_time</code>, <code>moving_time</code>) are stored. Also the values of resting and moving time relative to the <code>total_time</code> are calculated (<code>t_rest_rel</code>, <code>t_mov_rel</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">total_time =<span class="st"> </span><span class="kw">sum</span>(gps$delta_time, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

resting_ind &lt;-<span class="st"> </span><span class="kw">which</span>(gps$speed &lt;<span class="st"> </span><span class="dv">1</span>)
resting_time &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[resting_ind], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_rest_rel &lt;-<span class="st"> </span>resting_time /<span class="st"> </span>total_time

moving_ind &lt;-<span class="st"> </span><span class="kw">which</span>(gps$speed &gt;=<span class="st"> </span><span class="dv">1</span>)
moving_time &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[-resting_ind], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_mov_rel &lt;-<span class="st"> </span>moving_time /<span class="st"> </span>total_time</code></pre></div>
<p>This is followed by further segmentation of moving time by determining how much of that time was spent cycling ascending, descending and on flat. In the first step we exclude the resting periods from the input <code>gps</code> data frame. Then we calculate the total ascending time <code>time_asc</code> by summing up the time differences <code>delta_time</code> of all GPS samples that have a positive hill grade <code>grade_smooth</code>. The total descending time <code>time_desc</code> is calculated by summing up the time differences <code>delta_time</code> of all GPS samples that have a negative hill grade <code>grade_smooth</code>. The total time cycling on flat <code>time_flat</code> is calculated by summing up the time differences <code>delta_time</code> of all GPS samples that have the hill grade <code>grade_smooth</code> equal to zero. Additionally all the relative values (to <code>total_time</code>) of these times are determined (<code>t_asc_rel</code>, <code>t_desc_rel</code> and <code>t_flat_rel</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Segment only the moving part of the route</span>
gps &lt;-<span class="st"> </span>gps[-resting_ind,]

<span class="co"># Determine the total time spent ascending</span>
time_asc &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[<span class="kw">which</span>(gps$grade_smooth &gt;<span class="st"> </span><span class="dv">0</span>)], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_asc_rel &lt;-<span class="st"> </span>time_asc /<span class="st"> </span>total_time

<span class="co"># Determine the total time spent descending</span>
time_desc &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[<span class="kw">which</span>(gps$grade_smooth &lt;<span class="st"> </span><span class="dv">0</span>)], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_desc_rel &lt;-<span class="st"> </span>time_desc /<span class="st"> </span>total_time

<span class="co"># Determine the total time spent on flat</span>
time_flat &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[<span class="kw">which</span>(gps$grade_smooth ==<span class="st"> </span><span class="dv">0</span>)], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_flat_rel &lt;-<span class="st"> </span>time_flat /<span class="st"> </span>total_time</code></pre></div>
<p>To conclude, the total time of GPS samples with undefined hill grade values (<code>NA</code>s) is also calculated. Samples with undefined hill grade values emerge beacuse of smoothing the elevation and distances. Finally, the values of time calculation are constructed into a data frame <code>time_div</code> which is then returned as function output in a list along with <code>resting_ind</code> and <code>moving_ind</code> vectors</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Determine the time with undefined (NA) grade because of smoothing</span>
time_NA &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_time[<span class="kw">which</span>(<span class="kw">is.na</span>(gps$grade_smooth))], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
t_NA_rel &lt;-<span class="st"> </span>time_NA /<span class="st"> </span>total_time

time_div &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">total_time =</span> total_time, <span class="dt">moving_time =</span> moving_time,
                       <span class="dt">t_mov_rel =</span> t_mov_rel, <span class="dt">resting_time =</span> resting_time,
                       <span class="dt">t_rest_rel =</span> t_rest_rel, <span class="dt">time_asc =</span> time_asc,
                       <span class="dt">t_asc_rel =</span> t_asc_rel, <span class="dt">time_desc =</span> time_desc,
                       <span class="dt">t_desc_rel =</span> t_desc_rel, <span class="dt">time_flat =</span> time_flat,
                       <span class="dt">t_flat_rel =</span> t_flat_rel, <span class="dt">time_NA =</span> time_NA,
                       <span class="dt">t_NA_rel =</span> t_NA_rel)
time_div</code></pre></div>
<pre><code>##   total_time moving_time t_mov_rel resting_time t_rest_rel time_asc
## 1       9095        8770 0.9642661          325 0.03573392     4688
##   t_asc_rel time_desc t_desc_rel time_flat  t_flat_rel time_NA    t_NA_rel
## 1  0.515448      3986  0.4382628        25 0.002748763      71 0.007806487</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## return(list(time_div = time_div, resting_ind = resting_ind, moving_ind = moving_ind))</code></pre></div>
</div>
<div id="detection-and-categorization-of-climbs" class="section level2">
<h2>Detection and categorization of climbs</h2>
<p>The <code>categorize</code> function is used to detect and categorize all climbs of the cycling route. The input argument of the function is the <code>gps</code> data frame containing longitude, latitude, elevation and time data of the route. This function detects the starting and ending point, length, average grade and category of climbs. The function output is a list containing the input <code>gps</code> data frame with added categorization data, the <code>climbs</code> data frame with the details of the climbs and the <code>total_vam</code> variable indicating the total vertical ascent meters (VAM) of the route. The function is called with:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">climb_cat &lt;-<span class="st"> </span><span class="kw">categorize</span>(gps)</code></pre></div>
<p>Since sample data frame <code>gps</code> with GPS data of a cycling route located within the <code>cycleR</code> package was already loaded, we can proceed by inspecting the function’s actions. Firstly, the time vector is converted to POSIXct format and smoothing of the distances <code>d</code>, elevation <code>ele</code>, hill grades <code>grade</code> and time differences <code>delta_time</code> are performed similarly as in the beginning of previously explained <code>segment_time</code> function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gps$time &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(gps$time, <span class="dt">format =</span> <span class="st">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>)

<span class="co"># Calculate distances between GPS data points if it doesn't exist</span>
if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;d&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$d &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">distanceGPS</span>(<span class="dt">lat1 =</span> gps$lat[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lat) -<span class="st"> </span>
<span class="st">        </span><span class="dv">1</span>)], <span class="dt">lon1 =</span> gps$lon[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lon) -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">lat2 =</span> gps$lat[<span class="dv">2</span>:<span class="kw">length</span>(gps$lat)], 
        <span class="dt">lon2 =</span> gps$lon[<span class="dv">2</span>:<span class="kw">length</span>(gps$lon)]))
}

<span class="co"># Smooth out the elevation and hill grade vectors using rolling mean value</span>
<span class="co"># Length of the smoothing window is determined so that it's approximately 1</span>
<span class="co"># minute long</span>
win_smooth &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">60</span>/<span class="kw">as.numeric</span>(<span class="kw">difftime</span>(<span class="kw">tail</span>(gps$time, <span class="dv">1</span>), gps$time[<span class="dv">1</span>], <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)/<span class="kw">length</span>(gps$time)), 
    <span class="dt">digits =</span> -<span class="dv">1</span>)
d_smooth &lt;-<span class="st"> </span>zoo::<span class="kw">rollapply</span>(gps$d, win_smooth, mean)
ele &lt;-<span class="st"> </span>zoo::<span class="kw">rollmean</span>(gps$ele, win_smooth)
grade &lt;-<span class="st"> </span>analyzeGPS::<span class="kw">gradeGPS</span>(ele, d_smooth)

<span class="co"># Insert the smoothened vectors into the main data frame</span>
gps$d_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
gps$d_smooth[<span class="dv">1</span>:<span class="kw">length</span>(d_smooth)] &lt;-<span class="st"> </span>d_smooth
gps$ele_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
gps$ele_smooth[<span class="dv">1</span>:<span class="kw">length</span>(ele)] &lt;-<span class="st"> </span>ele
gps$grade_smooth &lt;-<span class="st"> </span><span class="ot">NA</span>
gps$grade_smooth[<span class="dv">2</span>:(<span class="kw">length</span>(grade) +<span class="st"> </span><span class="dv">1</span>)] &lt;-<span class="st"> </span>grade

if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;delta_time&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$delta_time &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, <span class="kw">as.numeric</span>(<span class="kw">diff</span>(gps$time)))
}</code></pre></div>
<p>Additional preparation step in this case is calculation of elevation differences <code>delta_ele</code> executed on the smoothed elevation data</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if (<span class="kw">sum</span>(<span class="kw">names</span>(gps) ==<span class="st"> &quot;delta_ele&quot;</span>) ==<span class="st"> </span><span class="dv">0</span>) {
    gps$delta_ele &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, gps$ele_smooth[<span class="dv">2</span>:<span class="kw">length</span>(gps$ele_smooth)] -<span class="st"> </span>gps$ele_smooth[<span class="dv">1</span>:(<span class="kw">length</span>(gps$ele_smooth) -<span class="st"> </span>
<span class="st">        </span><span class="dv">1</span>)])
}</code></pre></div>
<p>Following the finished preparations, we can proceed with detection and categorization of climbs. This is based on the <a href="https://strava.zendesk.com/entries/20420292-How-are-Strava-climbs-categorized-For-Rides-">Strava categorization</a> which claims that categorization is based on the product of percent grade and the length of the climb in meters. If this product is greater than 8000 then it is a categorized climb (in our case “Cat 4”). The limit for “Cat 3” climbs is 16000, for “Cat 2” climbs 32000, for “Cat 1” climbs 64000 and for “Cat HC” climbs (the hardest climbs) the limit is 80000. The referenced page also claims that the minimum percent grade of a clmb must be 3% or higher. However, the initial search criteria in our case was 2 % or higher to ensure detection and categorization of all climbs according to the grade - length product (this enables detection of climbs that are not as steep, but are longer in length). All samples with the grade - length product lower than 8000 are categorized as “no_category”. With this information in mind, climb detection begins with detecting all lengths and values of runs of values in the vector <code>grade_smooth</code> that are greater than 2 % (0.02). This is executed using the <code>rle</code> function, which produces the <code>runs</code> list that includes vectors <code>lengths</code> and <code>values</code>. Elements of these two vectors contain information about length and value according to the condition used in <code>rle</code> function for each run. The indexes of runs of grade greater than 2 % are determined by extracting indexes of the positive (<code>TRUE</code>) runs in the vectors in the <code>runs</code> list and stored in <code>positives</code> vector</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">runs &lt;-<span class="st"> </span><span class="kw">rle</span>(gps$grade_smooth &gt;=<span class="st"> </span><span class="fl">0.02</span>)
<span class="kw">str</span>(runs)</code></pre></div>
<pre><code>## List of 2
##  $ lengths: int [1:135] 1 178 17 155 28 340 9 209 8 1 ...
##  $ values : logi [1:135] NA FALSE TRUE FALSE TRUE FALSE ...
##  - attr(*, &quot;class&quot;)= chr &quot;rle&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">positives &lt;-<span class="st"> </span><span class="kw">which</span>(runs$values)
<span class="kw">str</span>(positives)</code></pre></div>
<pre><code>##  int [1:43] 3 5 7 9 11 13 15 17 19 21 ...</code></pre>
<p>The extracted indexes in <code>positives</code> are used to create inital <code>hill</code> data frame containing the climb details, such as starting and ending point, average grade, total length and vertical ascent meters. Each line in the <code>hill</code> data frame represents details of a separate climb</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hill &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ind_start =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(positives)), <span class="dt">ind_end =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(positives)), 
    <span class="dt">len =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(positives)), <span class="dt">avg_grade =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(positives)), 
    <span class="dt">vam =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(positives)))

for (i in <span class="dv">1</span>:<span class="kw">length</span>(positives)) {
    hill$ind_start[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(runs$lengths[<span class="dv">1</span>:(positives[i] -<span class="st"> </span><span class="dv">1</span>)]) +<span class="st"> </span><span class="dv">1</span>
    hill$ind_end[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(runs$lengths[<span class="dv">1</span>:positives[i]])
    ind &lt;-<span class="st"> </span><span class="kw">seq</span>(hill$ind_start[i], hill$ind_end[i])
    hill$len[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[ind])
    hill$avg_grade[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[ind])
    hill$vam[i] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[i]] -<span class="st"> </span>gps$ele_smooth[hill$ind_start[i]]
}

<span class="kw">str</span>(hill)</code></pre></div>
<pre><code>## 'data.frame':    43 obs. of  5 variables:
##  $ ind_start: num  180 352 720 938 947 ...
##  $ ind_end  : num  196 379 728 945 951 ...
##  $ len      : num  144.3 236.8 109.3 64.8 46.8 ...
##  $ avg_grade: num  0.0278 0.0321 0.0245 0.021 0.0216 ...
##  $ vam      : num  3.86 7.332 1.97 1.376 0.804 ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ele, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>)
for (i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
    <span class="kw">lines</span>(<span class="dt">x =</span> <span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>), <span class="dt">y =</span> ele[<span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span>
<span class="st">        </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
<p>Of course at this stage, the number of climbs (rows in <code>hill</code>) is higher than one would say after a simple visual inspection of the elevation graph above. Therefore, to get closer to the actual result further inspection and analysis of data in the <code>hill</code> data frame is required. Firstly, we aggregate all slopes that are close together and interrupted only by short (less than <code>win_smooth</code>) reductions of grade (below 2 %). This means that we are searching for starting points of climbs in <code>hill</code> that are closer together than <code>win_smooth</code>. The climbs that match this condition and start close together are combined into a single climb that starts at the starting point of the first climb and ends at the ending point of the second climb. The length and average grade of the combined climb are the sum of lengths and average grade of all data points between the starting and ending point of the combined climb. Vertical ascent meters of the combined climb are calculated as the difference between elevation of the ending and starting points of the newly combined climb. The second climb is now obsolete and can be excluded from the <code>hill</code> data frame. Line indexes of all obsolete climbs are stored separately in <code>del_lines</code> vector and used to delete them after the <code>for</code> loop is finished. The indexes of deleted lines are also displayed just above the visualization of result in the figure below the following code chunk</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">del_lines &lt;-<span class="st"> </span><span class="ot">NA</span>

groups &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">diff</span>(hill$ind_start) &gt;<span class="st"> </span>win_smooth)
for (i in <span class="dv">1</span>:<span class="kw">length</span>(groups)) {
    if (i ==<span class="st"> </span><span class="dv">1</span>) {
        hill$ind_end[i] &lt;-<span class="st"> </span>hill$ind_end[groups[i]]
        hill$len[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[hill$ind_start[i]:hill$ind_end[i]])
        hill$avg_grade[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[i]:hill$ind_end[i]])
        hill$vam[i] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[i]] -<span class="st"> </span>gps$ele_smooth[hill$ind_start[i]]
        
        del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (i +<span class="st"> </span><span class="dv">1</span>):groups[i])
    } else {
        hill$ind_end[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span>hill$ind_end[groups[i]]
        hill$len[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[hill$ind_start[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>]:hill$ind_end[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]])
        hill$avg_grade[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[groups[i -<span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]:hill$ind_end[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]])
        hill$vam[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[groups[i -<span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]] -<span class="st"> </span>gps$ele_smooth[hill$ind_start[groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]
        
        if ((groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>) !=<span class="st"> </span>groups[i]) {
            del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (groups[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>):groups[i])
        }
        
    }
    if (i ==<span class="st"> </span><span class="kw">length</span>(groups)) {
        hill$ind_end[groups[i] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">tail</span>(hill$ind_end, <span class="dv">1</span>)
        hill$len[groups[i] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[hill$ind_start[groups[i] +<span class="st"> </span><span class="dv">1</span>]:hill$ind_end[groups[i] +<span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>]])
        hill$avg_grade[groups[i] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[groups[i] +<span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>]:hill$ind_end[groups[i] +<span class="st"> </span><span class="dv">1</span>]])
        hill$vam[groups[i] +<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[groups[i] +<span class="st"> </span><span class="dv">1</span>]] -<span class="st"> </span>
<span class="st">            </span>gps$ele_smooth[hill$ind_start[groups[i] +<span class="st"> </span><span class="dv">1</span>]]
        
        if ((groups[i] +<span class="st"> </span><span class="dv">1</span>) !=<span class="st"> </span><span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
            del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (groups[i] +<span class="st"> </span><span class="dv">1</span> +<span class="st"> </span><span class="dv">1</span>):<span class="kw">dim</span>(hill)[<span class="dv">1</span>])
        }
        
    }
    
}

del_lines &lt;-<span class="st"> </span>del_lines[-<span class="dv">1</span>]
del_lines</code></pre></div>
<pre><code>##  [1]  2  1  5  6 13 15 16 17 18 22 26 30 36 38 40 41 43</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hill &lt;-<span class="st"> </span>hill[-del_lines, ]

<span class="kw">str</span>(hill)</code></pre></div>
<pre><code>## 'data.frame':    26 obs. of  5 variables:
##  $ ind_start: num  720 938 1112 1201 1327 ...
##  $ ind_end  : num  728 1035 1146 1246 1336 ...
##  $ len      : num  109.3 922.6 347.5 383.2 78.1 ...
##  $ avg_grade: num  0.0245 0.0273 0.0405 0.0374 0.0237 ...
##  $ vam      : num  1.97 25.08 12.65 13.9 1.94 ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ele, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>)
for (i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
    <span class="kw">lines</span>(<span class="dt">x =</span> <span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>), <span class="dt">y =</span> ele[<span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span>
<span class="st">        </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
<p>The climbs are further aggregated based on the difference between the starting point of a climb and the ending point of a previous climb. Two climbs are aggregated if this difference is less than half of <code>win_smooth</code>. This aggregation is performed within a <code>while</code> loop using backsearch. If for a certain climb there exists a predecessor for which the described condition is true than a combined climb is created by updating the details of the previous climb using similar corrections as described in the previous aggregation step. The current climb is deleted after its details are used to create the combined climb. In the bottom of the following code chunk, the number of deleted lines (aggregated climbs) is indicated with variable <code>deleted_lines</code> and the resulting elevation graph is visualized</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dim_start &lt;-<span class="st"> </span><span class="kw">dim</span>(hill)[<span class="dv">1</span>]
i &lt;-<span class="st"> </span><span class="dv">2</span>
while(i &lt;=<span class="st"> </span><span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  if((hill$ind_start[i] -<span class="st"> </span>hill$ind_end[i -<span class="st"> </span><span class="dv">1</span>]) &lt;<span class="st"> </span>(win_smooth /<span class="st"> </span><span class="dv">2</span>)) {
    hill$ind_end[i -<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span>hill$ind_end[i]
    hill$len[i -<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[hill$ind_start[i -<span class="st"> </span><span class="dv">1</span>]:<span class="st"> </span>hill$ind_end[i -<span class="st"> </span><span class="dv">1</span>]])
    hill$avg_grade[i -<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[i -<span class="st"> </span><span class="dv">1</span>]:<span class="st"> </span>hill$ind_end[i -<span class="st"> </span><span class="dv">1</span>]])
    hill$vam[i -<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[i -<span class="st"> </span><span class="dv">1</span>]] -<span class="st"> </span>gps$ele_smooth[hill$ind_start[i -<span class="st"> </span><span class="dv">1</span>]]
    hill &lt;-<span class="st"> </span>hill[-i,]
  } else {
    i &lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
  }
}

deleted_lines &lt;-<span class="st"> </span>dim_start -<span class="st"> </span><span class="kw">dim</span>(hill)[<span class="dv">1</span>]
deleted_lines</code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(hill)</code></pre></div>
<pre><code>## 'data.frame':    23 obs. of  5 variables:
##  $ ind_start: num  720 938 1112 1201 1327 ...
##  $ ind_end  : num  728 1035 1146 1246 1336 ...
##  $ len      : num  109.3 922.6 347.5 383.2 78.1 ...
##  $ avg_grade: num  0.0245 0.0273 0.0405 0.0374 0.0237 ...
##  $ vam      : num  1.97 25.08 12.65 13.9 1.94 ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ele, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)
for(i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  <span class="kw">lines</span>(<span class="dt">x =</span> <span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>), <span class="dt">y =</span> ele[<span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
<p>These two steps ensure that we aggregate all climbs that are very close together interrupted by shorter intervals of data points with grade less than 2 %. However, we still have to consider longer climbs that have relatively short intervals of lower or even negative hill grade that don’t have a great effect on the general climb difficulty or category (e.g. in the elevation graphs around indexes 2800 and 3800). In the final aggregation step we will combine pairs of climbs whose combined length is greater than the distance between them. Indexes of these pairs are determined in a <code>for</code> loop and stored in the vector <code>groups2</code>. All consecutive indexes in the <code>groups2</code> vector are aggregated together and the corresponding hills will be combined together in a single move. The <code>gr_difference</code> variable stores the indexes of the hills to combine. The number of elements in <code>gr_difference</code> corresponds with the number of consecutive index groups in <code>groups2</code>. The hills are combined in the same way as described in the previous step. The indexes of deleted/aggregated climbs is displayed just above the final elevation graph in the end of the following code chunk</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">groups2 &lt;-<span class="st"> </span><span class="ot">NA</span>
for(i in <span class="dv">1</span>:(<span class="kw">dim</span>(hill)[<span class="dv">1</span>] -<span class="st"> </span><span class="dv">1</span>)){
  if((<span class="kw">sum</span>(gps$d[hill$ind_end[i]:<span class="st"> </span>hill$ind_start[i +<span class="st"> </span><span class="dv">1</span>]])) &lt;<span class="st"> </span><span class="kw">sum</span>(hill$len[i], hill$len[i +<span class="st"> </span><span class="dv">1</span>])) {
    groups2 &lt;-<span class="st"> </span><span class="kw">c</span>(groups2, i)
  }
}
groups2 &lt;-<span class="st"> </span>groups2[-<span class="dv">1</span>]
groups2</code></pre></div>
<pre><code>##  [1]  2  3  8  9 10 11 12 13 14 21 22</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gr_difference &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">diff</span>(groups2) &gt;<span class="st"> </span><span class="dv">1</span>)
gr_difference</code></pre></div>
<pre><code>## [1] 2 9</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">del_lines &lt;-<span class="st"> </span><span class="ot">NA</span>

for(i in <span class="dv">1</span>:<span class="kw">length</span>(gr_difference)) {
  if(i ==<span class="st"> </span><span class="dv">1</span>){
    hill$ind_end[groups2[i]] &lt;-<span class="st"> </span>hill$ind_end[groups2[gr_difference[i]]]
    hill$len[groups2[i]] &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$d[hill$ind_start[groups2[i]]:
<span class="st">                                        </span>hill$ind_end[groups2[i]]])
    hill$avg_grade[groups2[i]] &lt;-<span class="st"> </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[groups2[i]]:
<span class="st">                                                          </span>hill$ind_end[groups2[i]]])
    hill$vam[groups2[i]] &lt;-<span class="st"> </span>gps$ele_smooth[hill$ind_end[groups2[i]]] -<span class="st"> </span>
<span class="st">      </span>gps$ele_smooth[hill$ind_start[groups2[i]]]
    del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (groups2[i]+<span class="dv">1</span>):groups2[gr_difference[i]])
  } else {
    hill$ind_end[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span>hill$ind_end[groups2[gr_difference[i]]]
    hill$len[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span><span class="kw">sum</span>(gps$d[hill$ind_start[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]:
<span class="st">                  </span>hill$ind_end[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]])
    hill$avg_grade[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]:
<span class="st">                              </span>hill$ind_end[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]])
    hill$vam[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span>gps$ele_smooth[hill$ind_end[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]] -
<span class="st">      </span>gps$ele_smooth[hill$ind_start[groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]]]
    
    if((groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>]) !=<span class="st"> </span>(groups2[gr_difference[i]])) {
      del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (groups2[gr_difference[i -<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>):
<span class="st">                       </span>groups2[gr_difference[i]])
    } else {
      del_lines &lt;-<span class="st"> </span>del_lines
    }
    
  }
  if(i ==<span class="st"> </span><span class="kw">length</span>(gr_difference)) {
    hill$ind_end[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span>hill$ind_end[groups2[<span class="kw">length</span>(groups2)]]
    hill$len[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span><span class="kw">sum</span>(gps$d[hill$ind_start[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]:
<span class="st">                  </span>hill$ind_end[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]])
    hill$avg_grade[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span><span class="kw">mean</span>(gps$grade_smooth[hill$ind_start[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]:
<span class="st">                              </span>hill$ind_end[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]])
    hill$vam[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]] &lt;-<span class="st"> </span>
<span class="st">      </span>gps$ele_smooth[hill$ind_end[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]] -
<span class="st">      </span>gps$ele_smooth[hill$ind_start[groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]]]
    
    if((groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>]) !=<span class="st"> </span>(groups2[<span class="kw">length</span>(groups2)])) {
      del_lines &lt;-<span class="st"> </span><span class="kw">c</span>(del_lines, (groups2[gr_difference[i] +<span class="st"> </span><span class="dv">1</span>] +<span class="st"> </span><span class="dv">1</span>):
<span class="st">                       </span>(groups2[<span class="kw">length</span>(groups2)]))
    } else {
      del_lines &lt;-<span class="st"> </span>del_lines
    }
  }
}

del_lines &lt;-<span class="st"> </span>del_lines[-<span class="dv">1</span>]
del_lines</code></pre></div>
<pre><code>## [1]  3  9 10 11 12 13 14 22</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hill &lt;-<span class="st"> </span>hill[-del_lines,]
<span class="kw">str</span>(hill)</code></pre></div>
<pre><code>## 'data.frame':    15 obs. of  5 variables:
##  $ ind_start: num  720 938 1201 1327 1657 ...
##  $ ind_end  : num  728 1146 1246 1336 1694 ...
##  $ len      : num  109.3 1994.8 383.2 78.1 272.2 ...
##  $ avg_grade: num  0.0245 0.0161 0.0374 0.0237 0.041 ...
##  $ vam      : num  1.97 30.95 13.9 1.94 11.28 ...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ele, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)
for(i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  <span class="kw">lines</span>(<span class="dt">x =</span> <span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>), <span class="dt">y =</span> ele[<span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
<p>Finally, categorization of the detected climbs is performed. An additional variable <code>category</code> is added to the <code>hill</code> data frame, which includes the grade - length product. Its values are then divided in intervals with limits described earlier. After this the <code>category</code> values are factorized with values <code>no_category</code>, <code>4</code>, <code>3</code>, <code>2</code>, <code>1</code> and <code>HC</code>. The factorized vector <code>hill$category</code> is than inserted into the input <code>gps</code> data frame based on the hill starting and ending indexes</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hill$category &lt;-<span class="st"> </span>hill$len *<span class="st"> </span><span class="dv">100</span> *<span class="st"> </span>hill$avg_grade
hill$category &lt;-<span class="st"> </span><span class="kw">findInterval</span>(hill$category, <span class="kw">c</span>(<span class="dv">8000</span>, <span class="dv">16000</span>, <span class="dv">32000</span>, <span class="dv">64000</span>, <span class="dv">80000</span>))
hill$category &lt;-<span class="st"> </span><span class="kw">factor</span>(hill$category, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), 
                        <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;no_category&quot;</span>, <span class="st">&quot;4&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="st">&quot;HC&quot;</span>))

<span class="co"># Insert hill data into the main gps data frame</span>
gps$category &lt;-<span class="st"> </span><span class="dv">0</span>
for(i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  if(hill$category[i] !=<span class="st"> &quot;no_category&quot;</span>) {
    gps$category[hill$ind_start[i]:hill$ind_end[i]] &lt;-<span class="st"> </span><span class="kw">as.character</span>(hill$category[i])
  }
}
gps$category &lt;-<span class="st"> </span><span class="kw">factor</span>(gps$category, 
                       <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;0&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4&quot;</span>, <span class="st">&quot;HC&quot;</span>), 
                       <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;no_category&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4&quot;</span>, <span class="st">&quot;HC&quot;</span>))</code></pre></div>
<p>The function <code>categorize</code> is concluded by calculating the total vertical ascent meters (VAM) of the cycling route which is returned as a final result in a list together with <code>gps</code> and <code>hill</code> data frames</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">total_vam &lt;-<span class="st"> </span><span class="kw">sum</span>(gps$delta_ele[<span class="kw">which</span>(gps$grade_smooth &gt;<span class="st"> </span><span class="dv">0</span>)], <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

<span class="kw">str</span>(<span class="kw">list</span>(<span class="dt">gps =</span> gps, <span class="dt">climbs =</span> hill, <span class="dt">total_vam =</span> total_vam))</code></pre></div>
<pre><code>## List of 3
##  $ gps      :'data.frame':   7764 obs. of  13 variables:
##   ..$ lon         : num [1:7764] 14.4 14.4 14.4 14.4 14.4 ...
##   ..$ lat         : num [1:7764] 46 46 46 46 46 ...
##   ..$ ele         : num [1:7764] 296 296 296 296 296 ...
##   ..$ time        : POSIXct[1:7764], format: &quot;2015-06-02 14:59:55&quot; ...
##   ..$ tz_CEST     : chr [1:7764] &quot;2015-06-02 16:59:55&quot; &quot;2015-06-02 17:01:56&quot; &quot;2015-06-02 17:01:57&quot; &quot;2015-06-02 17:01:58&quot; ...
##   ..$ delta_time  : num [1:7764] NA 1 1 1 1 1 1 1 1 1 ...
##   ..$ d           : num [1:7764] NA 2.98 3.56 4.11 4.46 ...
##   ..$ speed       : num [1:7764] NA 2.98 3.56 4.11 4.46 ...
##   ..$ ele_smooth  : num [1:7764] 301 301 301 301 301 ...
##   ..$ d_smooth    : num [1:7764] NA 7.27 7.38 7.46 7.52 ...
##   ..$ grade_smooth: num [1:7764] NA 0.0121 0.01084 0.00939 0.00824 ...
##   ..$ delta_ele   : num [1:7764] NA 0.186 0.08 0.07 0.062 ...
##   ..$ category    : Factor w/ 6 levels &quot;no_category&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ climbs   :'data.frame':   15 obs. of  6 variables:
##   ..$ ind_start: num [1:15] 720 938 1201 1327 1657 ...
##   ..$ ind_end  : num [1:15] 728 1146 1246 1336 1694 ...
##   ..$ len      : num [1:15] 109.3 1994.8 383.2 78.1 272.2 ...
##   ..$ avg_grade: num [1:15] 0.0245 0.0161 0.0374 0.0237 0.041 ...
##   ..$ vam      : num [1:15] 1.97 30.95 13.9 1.94 11.28 ...
##   ..$ category : Factor w/ 6 levels &quot;no_category&quot;,..: 1 1 1 1 1 1 4 1 1 1 ...
##  $ total_vam: num 803</code></pre>
<p>In this case there is only one categorized (“Cat 2”) climb with the following details and visualization</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hill[<span class="kw">which</span>(hill$category !=<span class="st"> &quot;no_category&quot;</span>),]</code></pre></div>
<pre><code>##    ind_start ind_end      len  avg_grade     vam category
## 12      2122    3996 10727.41 0.03539187 329.058        2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ele, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)
for(i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  <span class="kw">lines</span>(<span class="dt">x =</span> <span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>), <span class="dt">y =</span> ele[<span class="kw">seq</span>(hill$ind_start[i] +<span class="st"> </span><span class="dv">1</span>, hill$ind_end[i] -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}

for(i in <span class="dv">1</span>:<span class="kw">dim</span>(hill)[<span class="dv">1</span>]) {
  if(hill$category[i] !=<span class="st"> &quot;no_category&quot;</span>) {
    <span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">c</span>(hill$ind_start[i], hill$ind_end[i]))),
         <span class="dt">y =</span> <span class="kw">mean</span>(gps$ele_smooth[<span class="kw">c</span>(hill$ind_start[i], hill$ind_end[i])]),
         <span class="dt">labels =</span> <span class="kw">paste</span>(<span class="st">&quot;Category&quot;</span>, hill$category[i], <span class="st">&quot;</span><span class="ch">\n</span><span class="st"> climb&quot;</span>))
  }
}</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
</div>
<div id="power-calculation" class="section level2">
<h2>Power calculation</h2>
<p>The <code>cycling_power</code> function is used to assess the total power produced by a cyclist on a bike ride given the GPS data and additional physical parameters, such as the combined mass of the cyclist and the bicycle, coefficients for rolling resistance and drag, air density, surface area of the cyclist facing the wind, wind speed. Specifically, the power required from a person to move on a bike between measured points of a GPS route is calculated, based on the formula <span class="math inline">\(P = Proll + Pdrag + Pclimb + Pacc\)</span>, where <code>Proll</code> is the power required to overcome the rolling resistance, <code>Pdrag</code> is the power required to overcome the wind resistance, <code>Pclimb</code> is the power required to overcome the pull of gravity and <code>Pacc</code> is the power required to accelerate from one speed to another. All power values in this function are calculated directly in Wats (W) since basic metric units are used throughout this package as well as the package <code>analyzeGPS</code>. Calculations were defined according to <a href="https://strava.zendesk.com/entries/20959332-Power-Calculations">Strava Power Calculations</a>. The usage of the <code>cycling_power</code> function is</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Pcycling &lt;- cycling_power(gps, m = 90, Crr = 0.004, Cd = 0.9, ro = 1.13, A = 0.5, 
##     windspeed = 0)
m &lt;-<span class="st"> </span><span class="dv">90</span>
Crr &lt;-<span class="st"> </span><span class="fl">0.004</span>
Cd &lt;-<span class="st"> </span><span class="fl">0.9</span>
ro &lt;-<span class="st"> </span><span class="fl">1.13</span>
A &lt;-<span class="st"> </span><span class="fl">0.5</span>
windspeed &lt;-<span class="st"> </span><span class="dv">0</span></code></pre></div>
<p>with the following arguments:</p>
<ul>
<li><code>gps</code>: the GPS data of the cycling route (longitude, latitude, time, elevation, …),</li>
<li><code>m</code>: the combined mass of the rider and the bicycle (in kilograms),</li>
<li><code>Crr</code>: the rolling resistance coefficient defined based on the type of bike (road, mtb, cross) used. The coefficient was determined according to data and calculations on <a href="http://www.analyticcycling.com/ForcesTires_Page.html">Analytic Cycling</a>,</li>
<li><code>Cd</code>: the drag coefficient (<a href="http://www.cyclingpowerlab.com/CyclingAerodynamics.aspx">its value depends on the bike, equipment and rider position</a>; typical values can also be found in: Wilson, David Gordon, and Jim Papadopoulos. Bicycling science, p. 188. Mit Press, 2004.),</li>
<li><code>ro</code>: air density (in kg/m^3). At 25 degrees Celsius and 300 m elevation air density is approximately 1.13 kg/m^3 using <a href="http://www.denysschen.com/catalogue/density.aspx">this calculator</a>,</li>
<li><code>A</code>: the surface area of the rider facing the wind with <a href="http://www.cyclingpowerlab.com/CyclingAerodynamics.aspx">typical values</a> between 0.4 and 0.7 (typical values can also be found in: Wilson, David Gordon, and Jim Papadopoulos. Bicycling science, p. 188. Mit Press, 2004.),</li>
<li><code>windspeed</code>: average wind speed in m/s. Head wind is given as a negative number and tail wind is given as a positive number. This argument has value of 0 if there is no information about wind speed (default).</li>
</ul>
<p>Default values of all input arguments apart from the <code>gps</code> data frame are set to 0 by function definition. In case any of them is missing, the calculation that requires it, isn’t performed and returns <code>NA</code> values for the coresponding part of the output.</p>
<p>Once the function is called it begins by prepairing all the data needed for the power calculations. The preparation of the data is almost the same as with previously described functions <code>segment_time</code> and <code>categorize</code> with the exception of defining the vector of smoothed speed and acceleration values and the value of gravitational pull (9.81 m/s^2). The smoothed speed <code>speed_smooth</code> is calculated directly from the smoothed distnace vector <code>d</code> by dividing those values with the average sampling time of the GPS data. The smoothed speed values are then used to calculate the smoothed acceleration values by dividing them with the time differences between samples (ba applying the <code>accGPS</code> function of the <code>analyzeGPS</code> package)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="fl">9.81</span>

gps$time &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(gps$time, <span class="dt">format =</span> <span class="st">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>)

<span class="co"># Length of the smoothing window is determined so that it's approximately 1 minute long</span>
win_smooth &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">60</span> /<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">difftime</span>(<span class="kw">tail</span>(gps$time, <span class="dv">1</span>), gps$time[<span class="dv">1</span>], <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>) /<span class="st"> </span><span class="kw">length</span>(gps$time)), <span class="dt">digits =</span> -<span class="dv">1</span>)

<span class="co"># Smooth out the distances using rolling mean value</span>
d &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">distanceGPS</span>(<span class="dt">lat1 =</span> gps$lat[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lat)-<span class="dv">1</span>)], <span class="dt">lon1 =</span> gps$lon[<span class="dv">1</span>:(<span class="kw">length</span>(gps$lon)-<span class="dv">1</span>)],
                                          <span class="dt">lat2 =</span> gps$lat[<span class="dv">2</span>:<span class="kw">length</span>(gps$lat)], <span class="dt">lon2 =</span> gps$lon[<span class="dv">2</span>:<span class="kw">length</span>(gps$lon)]))

d_smooth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(d))
d_smooth[<span class="dv">1</span>:(<span class="kw">length</span>(d_smooth) -<span class="st"> </span>win_smooth +<span class="st"> </span><span class="dv">1</span>)] &lt;-<span class="st"> </span>zoo::<span class="kw">rollapply</span>(d, win_smooth, mean)

delta_time &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, <span class="kw">as.numeric</span>(<span class="kw">difftime</span>(gps$time[-<span class="dv">1</span>], gps$time[<span class="dv">1</span>:(<span class="kw">length</span>(gps$time) -<span class="st"> </span><span class="dv">1</span>)], <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)))
samp_avg &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">mean</span>(delta_time, <span class="dt">na.rm =</span> T), <span class="dt">digits =</span> <span class="dv">0</span>)

speed_smooth &lt;-<span class="st"> </span>d_smooth /<span class="st"> </span>samp_avg

acc_smooth &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">accGPS</span>(gps$time, speed_smooth))

ele_smooth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(gps$ele))
ele_smooth[<span class="dv">1</span>:(<span class="kw">length</span>(gps$ele) -<span class="st"> </span>win_smooth +<span class="st"> </span><span class="dv">1</span>)] &lt;-<span class="st"> </span>zoo::<span class="kw">rollmean</span>(gps$ele, win_smooth)
grade_smooth &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, analyzeGPS::<span class="kw">gradeGPS</span>(ele_smooth, d_smooth))</code></pre></div>
<p>The prepared data is then used with other input arguments of the function to calculate the power values. First, the rolling power is calculated by following the forumla <span class="math display">\[Proll = Crr * N * speed = Crr * m * g * cos(atan(grade)) * speed\]</span>, where <span class="math inline">\(N\)</span> is the normal force of the bike and the athlete against gravity and is calculated as <span class="math inline">\(m * g * cos(atan(grade))\)</span> and <span class="math inline">\(speed\)</span> is the average speed between two GPS data points (values <span class="math inline">\(m\)</span>, <span class="math inline">\(g\)</span>, <span class="math inline">\(Crr\)</span> and <span class="math inline">\(grade\)</span> were previously explained). Before the calculation of the rolling power it is checked if all the necessary parameters are defined with values different than default. If any of these values is missing, <code>Proll</code> is filled with <code>NA</code> values</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if((Crr !=<span class="st"> </span><span class="dv">0</span>) &amp;<span class="st"> </span>(m !=<span class="st"> </span><span class="dv">0</span>)){
  Proll &lt;-<span class="st"> </span>Crr *<span class="st"> </span>m *<span class="st"> </span>g *<span class="st"> </span><span class="kw">cos</span>(<span class="kw">atan</span>(grade_smooth)) *<span class="st"> </span>speed_smooth
} else {
  Proll &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(speed_smooth))
}</code></pre></div>
<p>Next, the power to overcome drag is calculated by following the forumla <span class="math display">\[Pdrag = 0.5 * ro * v^3 * Cd * A = 0.5 * ro * (speed - windspeed)^3 * Cd * A\]</span>, where <span class="math inline">\(v\)</span> is the air speed of the bike and the athlete and is calculated as <span class="math inline">\(speed - windspeed\)</span> (values <span class="math inline">\(ro\)</span>, <span class="math inline">\(Cd\)</span>, and <span class="math inline">\(A\)</span> were previously explained). In the case of head wind the wind speed is negative, which increases air speed and drag force, and in the case of tail wind the wind speed is positive, which decreases air speed and drage force. Before the calculation of the power to overcome drag it is checked if all the necessary parameters are defined with values different than default. If any of these values is missing, <code>Pdrag</code> is filled with <code>NA</code> values</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if((Cd !=<span class="st"> </span><span class="dv">0</span>) &amp;<span class="st"> </span>(ro !=<span class="st"> </span><span class="dv">0</span>) &amp;<span class="st"> </span>(A !=<span class="st"> </span><span class="dv">0</span>)){
  Pdrag &lt;-<span class="st"> </span><span class="fl">0.5</span> *<span class="st"> </span>ro *<span class="st"> </span>(speed_smooth -<span class="st"> </span>windspeed)^<span class="dv">3</span> *<span class="st"> </span>Cd *<span class="st"> </span>A
} else {
  Pdrag &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(speed_smooth))
}</code></pre></div>
<p>Next, the power to overcome the pull of gravity while riding up an incline (climbing power) is calculated by following the forumla <span class="math display">\[Pclimb = Fd * speed = m * g * sin(atan(grade)) * speed\]</span>, where <span class="math inline">\(Fd\)</span> is the component of the gravity force of the bike and the athlete parallel to the ground and is calculated as <span class="math inline">\(m * g * sin(atan(grade))\)</span> (other values were previously explained). In the case of negative hill grade (downhill ride) the climbing power is also negative (gravity is supplying power), and in the case of positive hill grade (uphill ride) the climbing power is also positive (bike rider is supplying power). Before the calculation of the climbing power it is checked if all the necessary parameters are defined with values different than default. If any of these values is missing, <code>Pclimb</code> is filled with <code>NA</code> values</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(m !=<span class="st"> </span><span class="dv">0</span>){
  Pclimb &lt;-<span class="st"> </span>m *<span class="st"> </span>g *<span class="st"> </span><span class="kw">sin</span>(<span class="kw">atan</span>(grade_smooth)) *<span class="st"> </span>speed_smooth
} else {
  Pclimb &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(speed_smooth))
}</code></pre></div>
<p>Next, the power required to accelerate from one speed to another (accelerating power) is calculated by following the forumla <span class="math display">\[Pacc =  m * acc * v\]</span>, where <span class="math inline">\(acc\)</span> is the average acceleration (smoothed) between two data points (other values were previously explained). In the case of negative speed difference (decceleration, slowing down) the accelerating power is also negative (power from braking, wind resistance, the bike rider is not supplying power), and in the case of positive speed difference (acceleration, speeding up) the accelerating power is also positive (bike rider is supplying power). Before the calculation of the acceleration power it is checked if all the necessary parameters are defined with values different than default. If any of these values is missing, <code>Pacc</code> is filled with <code>NA</code> values</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(m !=<span class="st"> </span><span class="dv">0</span>){
  Pacc &lt;-<span class="st"> </span>m *<span class="st"> </span>acc_smooth *<span class="st"> </span>speed_smooth
} else {
  Pacc &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(speed_smooth))
}</code></pre></div>
<p>Finally, the total cycling power <code>Ptotal</code> is calculated by summing up the previously calculated partial power values. In parallel all the power values are packed in a data frame, which is returned as the result of the function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Pcycle &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Proll =</span> Proll, <span class="dt">Pdrag =</span> Pdrag, <span class="dt">Pclimb =</span> Pclimb, <span class="dt">Pacc =</span> Pacc)

Pcycle$Ptotal &lt;-<span class="st"> </span><span class="kw">rowSums</span>(Pcycle, <span class="dt">na.rm =</span> T)

<span class="kw">str</span>(Pcycle)</code></pre></div>
<pre><code>## 'data.frame':    7764 obs. of  5 variables:
##  $ Proll : num  NA 26.1 26.1 26.3 26.6 ...
##  $ Pdrag : num  NA 103 102 105 108 ...
##  $ Pclimb: num  NA 77.7 70.6 61.8 54.7 ...
##  $ Pacc  : num  NA NA -13.9 50 46.6 ...
##  $ Ptotal: num  0 207 185 243 236 ...</code></pre>
<p>From here on we can visualize the calculated total power or any of its components</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(gps$time, Pcycle$Ptotal, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
<p>We can calculate the average power input of the cyclist</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(Pcycle$Ptotal, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] 202.9225</code></pre>
<p>Or we can calculate the average wattage per kilogram and visualize the power curve</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(Pcycle$Ptotal /<span class="st"> </span>m, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] 2.254695</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(gps$time, Pcycle$Ptotal /<span class="st"> </span>m, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" title alt style="display: block; margin: auto;" /></p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
